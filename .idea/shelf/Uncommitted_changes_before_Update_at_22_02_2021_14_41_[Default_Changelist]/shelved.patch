Index: BDD/fonc_bdd.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package BDD\r\n\r\nimport (\r\n\t\"database/sql\"\r\n\t\"fmt\"\r\n\t\"github.com/aodin/date\"\r\n\t_ \"github.com/aodin/date\"\r\n\t\"gitlab.univ-nantes.fr/E192543L/projet-s3/modele/logs\"\r\n\t\"golang.org/x/crypto/bcrypt\"\r\n\t\"math/rand\"\r\n)\r\n\r\n// Structure a réutiliser un peu partout\r\ntype Etudiant struct {\r\n\tLogin      string\r\n\tPassword   string\r\n\tPrenom     string\r\n\tNom        string\r\n\tMail       string\r\n\tCorrecteur bool\r\n}\r\n\r\ntype Admin struct {\r\n\tLogin    string\r\n\tPassword string\r\n}\r\n\r\ntype EtudiantMail struct {\r\n\tLogin  string\r\n\tPrenom string\r\n\tNom    string\r\n\tMail   string\r\n\tDefis  []ResBDD\r\n}\r\n\r\ntype ResBDD struct {\r\n\tLogin     string\r\n\tDefi      int\r\n\tEtat      int\r\n\tTentative int\r\n}\r\ntype ParticipantDefi struct {\r\n\tEtudiant Etudiant\r\n\tResultat ResBDD\r\n}\r\n\r\ntype Defi struct {\r\n\tNum        int\r\n\tDate_debut date.Date\r\n\tDate_fin   date.Date\r\n}\r\n\r\nvar db, _ = sql.Open(\"sqlite3\", \"./BDD/database.db\")\r\n\r\n/**\r\nFonction qui initialise les tables vides\r\n*/\r\nfunc InitBDD() {\r\n\r\n\tstmt, err := db.Prepare(\"CREATE TABLE IF NOT EXISTS Etudiant (\" +\r\n\t\t\"login TEXT PRIMARY KEY, \" +\r\n\t\t\"password TEXT NOT NULL, \" +\r\n\t\t\"prenom TEXT NOT NULL,\" +\r\n\t\t\"nom TEXT NOT NULL,\" +\r\n\t\t\"mail TEXT NOT NULL,\" +\r\n\t\t\"correcteur BOOLEAN NOT NULL\" +\r\n\t\t\");\")\r\n\tif err != nil {\r\n\t\tfmt.Println(\"prblm table Etudiant\" + err.Error())\r\n\t}\r\n\tstmt.Exec()\r\n\r\n\tstmt, err = db.Prepare(\"CREATE TABLE IF NOT EXISTS Defis (\" +\r\n\t\t\"numero INTEGER PRIMARY KEY AUTOINCREMENT,\" +\r\n\t\t\"date_debut TEXT NOT NULL,\" +\r\n\t\t\"date_fin TEXT NOT NULL\" +\r\n\t\t\")\")\r\n\tif err != nil {\r\n\t\tfmt.Println(\"Erreur création table Defis \" + err.Error())\r\n\t}\r\n\tstmt.Exec()\r\n\r\n\tstmt, err = db.Prepare(\"CREATE TABLE IF NOT EXISTS Resultat (\" +\r\n\t\t\"login TEXT NOT NULL,\" +\r\n\t\t\"defi INTEGER NOT NULL,\" +\r\n\t\t\"etat INTEGER NOT NULL,\" + // 2 états : 1 (réussi), 0 (non réussi), -1 (non testé)\r\n\t\t\"tentative INTEGER NOT NULL,\" + // Nombre de tentative au test\r\n\t\t\"FOREIGN KEY (login) REFERENCES Etudiant(login)\" +\r\n\t\t\"FOREIGN KEY (defi) REFERENCES Defis(numero)\" +\r\n\t\t\")\")\r\n\tif err != nil {\r\n\t\tfmt.Println(\"prblm table ResTest\" + err.Error())\r\n\t}\r\n\tstmt.Exec()\r\n\r\n\tstmt, err = db.Prepare(\"CREATE TABLE IF NOT EXISTS Token (\" +\r\n\t\t\"login TEXT NOT NULL PRIMARY KEY ,\" +\r\n\t\t\"token TEXT NOT NULL,\" +\r\n\t\t\"FOREIGN KEY(login) REFERENCES Etudiant(login)\" +\r\n\t\t\")\")\r\n\tif err != nil {\r\n\t\tfmt.Println(\"Erreur dans la table Token\" + err.Error())\r\n\t}\r\n\tstmt.Exec()\r\n\r\n\tstmt, err = db.Prepare(\"CREATE TABLE IF NOT EXISTS Administrateur (\" +\r\n\t\t\"login TEXT NOT NULL PRIMARY KEY ,\" +\r\n\t\t\"password TEXT NOT NULL\" +\r\n\t\t\")\")\r\n\tif err != nil {\r\n\t\tfmt.Println(\"Erreur dans la table Administrateur\" + err.Error())\r\n\t}\r\n\tstmt.Exec()\r\n\r\n\tstmt.Close()\r\n}\r\n\r\n/**\r\nEnregistre un étudiant dans la table Etudiant\r\n*/\r\nfunc Register(etu Etudiant) bool {\r\n\tstmt, _ := db.Prepare(\"INSERT INTO Etudiant values(?,?,?,?,?,?)\")\r\n\r\n\t_, err := stmt.Exec(etu.Login, etu.Password, etu.Prenom, etu.Nom, etu.Mail, false)\r\n\tif err != nil {\r\n\t\tlogs.WriteLog(\"BDD.Register\", err.Error())\r\n\t\treturn false\r\n\t}\r\n\tlogs.WriteLog(\"Register\", etu.Login+\" est enregistré\")\r\n\tstmt.Close()\r\n\treturn true\r\n}\r\n\r\n/**\r\nEnregistre un admin dans la table Administrateur\r\n*/\r\nfunc RegisterAdmin(admin Admin) bool {\r\n\tstmt, err := db.Prepare(\"INSERT INTO Administrateur values(?,?)\")\r\n\tif err != nil {\r\n\t\tfmt.Println(err)\r\n\t}\r\n\r\n\tpasswordHashed, err := bcrypt.GenerateFromPassword([]byte(admin.Password), 14)\r\n\r\n\t_, err = stmt.Exec(admin.Login, passwordHashed)\r\n\tif err != nil {\r\n\t\tfmt.Println(err)\r\n\t\treturn false\r\n\t}\r\n\tfmt.Println(\"l'admin de login : \" + admin.Login + \" a été enregistré dans la bdd\\n\")\r\n\tstmt.Close()\r\n\treturn true\r\n}\r\n\r\n/**\r\nvérifie que le couple login,password existe dans la table Etudiant\r\n*/\r\nfunc LoginCorrect(id string, password string) bool {\r\n\tvar passwordHashed string\r\n\trow := db.QueryRow(\"SELECT password FROM Etudiant WHERE login = $1\", id)\r\n\tif row == nil { // pas de compte avec ce login\r\n\t\treturn false\r\n\t}\r\n\terr := row.Scan(&passwordHashed) // cast/parse du res de la requète en string dans passwordHashed\r\n\tif err != nil {\r\n\t\tlogs.WriteLog(\"BDD.LoginCorrect\", err.Error())\r\n\t}\r\n\terrCompare := bcrypt.CompareHashAndPassword([]byte(passwordHashed), []byte(password)) // comparaison du hashé et du clair\r\n\treturn errCompare == nil                                                              // si nil -> ça match, sinon non\r\n\r\n\t/* Ancient système\r\n\tstmt := \"SELECT * FROM Etudiant WHERE login = ? AND password = ?\"\r\n\trow, _ := db.Query(stmt, id, password)\r\n\tif row.Next() {\r\n\t\trow.Close()\r\n\t\treturn true\r\n\t}\r\n\trow.Close()\r\n\treturn false*/\r\n}\r\n\r\n/**\r\nvérifie que le couple login,password existe dans la table Administrateur\r\n*/\r\nfunc LoginCorrectAdmin(id string, password string) bool {\r\n\tvar passwordHashed string\r\n\trow := db.QueryRow(\"SELECT password FROM administrateur WHERE login = $1\", id)\r\n\terrScan := row.Scan(&passwordHashed) // cast/parse du res de la requète en string dans passwordHashed\r\n\tif errScan != nil {\r\n\t\tlogs.WriteLog(id, \"login admin inconnu\")\r\n\t}\r\n\terrCompare := bcrypt.CompareHashAndPassword([]byte(passwordHashed), []byte(password)) // comparaison du hashé et du clair\r\n\treturn errCompare == nil                                                              // si nil -> ça match, sinon non\r\n}\r\n\r\n/**\r\nrécupère les informations personnelles d'un étudiant\r\n*/\r\nfunc GetEtudiant(id string) Etudiant {\r\n\tvar etu Etudiant\r\n\trow := db.QueryRow(\"SELECT * FROM Etudiant WHERE login = $1\", id)\r\n\terr := row.Scan(&etu.Login, &etu.Password, &etu.Prenom, &etu.Nom, &etu.Mail, &etu.Correcteur)\r\n\r\n\tif err != nil {\r\n\t\tlogs.WriteLog(\"BDD.GetEtudiant\", err.Error())\r\n\t}\r\n\treturn etu\r\n}\r\n\r\n/**\r\nrécupère les informations personnelles d'un admin\r\n*/\r\nfunc GetAdmin(id string) Admin {\r\n\tvar admin Admin\r\n\trow := db.QueryRow(\"SELECT * FROM Administrateur WHERE login = $1\", id)\r\n\terr := row.Scan(&admin.Login, &admin.Password)\r\n\r\n\tif err != nil {\r\n\t\tfmt.Printf(\"Problème de row.Scan() : \", err)\r\n\t}\r\n\treturn admin\r\n}\r\n\r\n// testé\r\nfunc GetNameByToken(token string) string {\r\n\tvar login string\r\n\trow := db.QueryRow(\"SELECT * FROM token WHERE token = $1\", token)\r\n\terr := row.Scan(&login, &token)\r\n\tif err != nil {\r\n\t\tlogs.WriteLog(\"BDD.GetNameByToken\", err.Error())\r\n\t}\r\n\treturn login\r\n}\r\n\r\n// testé\r\nfunc InsertToken(login string, token string) {\r\n\r\n\tstmt, _ := db.Prepare(\"DELETE FROM Token where login = ?\")\r\n\tstmt.Exec(login)\r\n\tstmt, _ = db.Prepare(\"INSERT INTO Token values(?,?)\")\r\n\t_, err := stmt.Exec(login, token)\r\n\tif err != nil {\r\n\t\tlogs.WriteLog(\"BDD.InsertToken\", err.Error())\r\n\t}\r\n\tstmt.Close()\r\n}\r\n\r\n// testé\r\nfunc DeleteToken(login string) {\r\n\tstmt, _ := db.Prepare(\"DELETE FROM token WHERE login = ?\")\r\n\t_, err := stmt.Exec(login)\r\n\tif err != nil {\r\n\t\tlogs.WriteLog(\"BDD.DeleteToken\", err.Error())\r\n\t}\r\n\tstmt.Close()\r\n}\r\n\r\nfunc TokenExiste(token string) bool {\r\n\tvar (\r\n\t\tlog string\r\n\t\ttok string\r\n\t)\r\n\trow := db.QueryRow(\"SELECT * FROM token WHERE token = $1\", token)\r\n\terr := row.Scan(&log, &tok)\r\n\tif err != nil {\r\n\t\treturn false\r\n\t}\r\n\treturn true\r\n}\r\n\r\nfunc TokenRole(token string) string {\r\n\tvar (\r\n\t\tlogin string\r\n\t)\r\n\trow := db.QueryRow(\"SELECT login FROM token WHERE token = $1\", token)\r\n\terr := row.Scan(&login)\r\n\tif err != nil {\r\n\t\treturn \"\"\r\n\t}\r\n\r\n\tvar nb int\r\n\trow = db.QueryRow(\"SELECT  count(*) FROM etudiant WHERE login = $1\", login)\r\n\terr = row.Scan(&nb)\r\n\tif err != nil {\r\n\r\n\t}\r\n\tif nb == 1 {\r\n\t\treturn \"etudiants\"\r\n\t}\r\n\r\n\trow = db.QueryRow(\"SELECT  count(*) FROM administrateur WHERE login = $1\", login)\r\n\terr = row.Scan(&nb)\r\n\tif nb == 1 {\r\n\t\treturn \"administrateur\"\r\n\t}\r\n\r\n\treturn \"\"\r\n}\r\n\r\nfunc ResetToken() {\r\n\tstmt, _ := db.Prepare(\"TRUNCATE TABLE token;\")\r\n\tif _, err := stmt.Exec(); err != nil {\r\n\t\tfmt.Printf(\"erreur clear de la table token\")\r\n\t}\r\n\tstmt.Close()\r\n}\r\n\r\n/**\r\nadmin == true : fonction lancé par l'admin pour modifier les valeurs\r\nadmin == false : fonction lancé par un étudiant lors d'une nouvelle tentative de test\r\n(si c'est false, tentative++)\r\n*/\r\nfunc SaveResultat(lelogin string, lenum_defi int, letat int, admin bool) {\r\n\tvar res ResBDD\r\n\trow := db.QueryRow(\"SELECT * FROM Resultat WHERE login = $1 AND defi = $2\", lelogin, lenum_defi)\r\n\r\n\tif err := row.Scan(&res.Login, &res.Defi, &res.Etat, &res.Tentative); err != nil {\r\n\t\tstmt, _ := db.Prepare(\"INSERT INTO Resultat values(?,?,?,?)\")\r\n\t\t_, err = stmt.Exec(lelogin, lenum_defi, letat, 1)\r\n\t\tstmt.Close()\r\n\t} else {\r\n\t\tstmt, _ := db.Prepare(\"UPDATE Resultat SET etat = ?, tentative = ? WHERE login = ? AND defi = ?\")\r\n\t\tif admin {\r\n\t\t\tstmt.Exec(res.Etat, res.Tentative, res.Login, res.Defi)\r\n\t\t} else {\r\n\t\t\tstmt.Exec(res.Etat, res.Tentative+1, res.Login, res.Defi)\r\n\t\t}\r\n\t\tstmt.Close()\r\n\t}\r\n\r\n}\r\n\r\n/**\r\nRécupère la liste des étudiants de la table Etudiant\r\n*/\r\nfunc GetEtudiants() []Etudiant {\r\n\tvar etu Etudiant\r\n\tetudiants := make([]Etudiant, 0)\r\n\trow, err := db.Query(\"SELECT * FROM Etudiant\")\r\n\tdefer row.Close()\r\n\tif err != nil {\r\n\t\tlogs.WriteLog(\"BDD.GetEtudiants\", err.Error())\r\n\t}\r\n\tfor row.Next() {\r\n\t\trow.Scan(&etu.Login, &etu.Password, &etu.Prenom, &etu.Nom, &etu.Mail, &etu.Correcteur)\r\n\t\tetudiants = append(etudiants, etu)\r\n\t}\r\n\treturn etudiants\r\n}\r\n\r\n/**\r\nRécupère le résultat d'un étudiant pour un défi spécifique\r\n*/\r\nfunc GetResult(login string, defi int) ResBDD {\r\n\tvar res ResBDD\r\n\trow := db.QueryRow(\"SELECT * FROM Resultat WHERE login = $1 AND defi = $2\", login, defi)\r\n\tif err := row.Scan(&res.Login, &res.Defi, &res.Etat, &res.Tentative); err != nil {\r\n\t\tlogs.WriteLog(\"BDD.GetResult\", err.Error())\r\n\t}\r\n\treturn res\r\n}\r\n\r\n/**\r\nAjoute un défi à la table Defis\r\n*/\r\nfunc AddDefi(dateD date.Date, dateF date.Date) {\r\n\tstmt, err := db.Prepare(\"INSERT INTO Defis(date_debut,date_fin) values(?,?)\")\r\n\t_, err = stmt.Exec(dateD.String(), dateF.String())\r\n\tif err != nil {\r\n\t\tlogs.WriteLog(\"BDD.AddDefi\", err.Error())\r\n\t}\r\n\tstmt.Close()\r\n}\r\n\r\n/**\r\nModifie le défi de numéro num\r\n*/\r\nfunc ModifyDefi(num int, dateD date.Date, dateF date.Date) {\r\n\tstmt, _ := db.Prepare(\"UPDATE Defis SET date_debut = ?, date_fin = ? where numero = ?\")\r\n\tif _, err := stmt.Exec(dateD.String(), dateF.String(), num); err != nil {\r\n\t\tlogs.WriteLog(\"BDD.ModifyDefi\", err.Error())\r\n\t}\r\n\tstmt.Close()\r\n}\r\n\r\nfunc GetDefis() []Defi {\r\n\tvar (\r\n\t\tdebutString string\r\n\t\tfinString   string\r\n\t\tdefi        Defi\r\n\t)\r\n\tdefis := make([]Defi, 0)\r\n\trow, err := db.Query(\"SELECT * FROM Defis\")\r\n\tdefer row.Close()\r\n\tif err != nil {\r\n\t\tlogs.WriteLog(\"BDD.GetDefis\", err.Error())\r\n\t}\r\n\tfor row.Next() {\r\n\t\trow.Scan(&defi.Num, &debutString, &finString)\r\n\t\tdefi.Date_debut, _ = date.Parse(debutString)\r\n\t\tdefi.Date_fin, _ = date.Parse(finString)\r\n\t\tdefis = append(defis, defi)\r\n\t}\r\n\tif len(defis) == 0 {\r\n\t\treturn nil\r\n\t}\r\n\treturn defis\r\n}\r\n\r\nfunc GetDefiActuel() Defi {\r\n\tdefis := GetDefis()\r\n\r\n\tdefiActuel := Defi{\r\n\t\tNum:        -1,\r\n\t\tDate_debut: date.Date{},\r\n\t\tDate_fin:   date.Date{},\r\n\t}\r\n\tfor _, d := range defis {\r\n\t\tif date.Today().Within(date.NewRange(d.Date_debut, d.Date_fin)) {\r\n\t\t\tdefiActuel = d\r\n\t\t}\r\n\t}\r\n\treturn defiActuel\r\n}\r\n\r\n//selectionne quel étudiant sera correcteur en fonction de si il a réussi et si il a déjà été correcteur\r\nfunc GetEtudiantCorrecteur(num_defi int) string {\r\n\tvar t = make([]string, 0)\r\n\tvar res string\r\n\tvar aleatoire int\r\n\tvar logfinal string\r\n\trow, err := db.Query(\"Select Login FROM Resultat r, Etudiant e WHERE r.Defi = $1 AND r.Etat = 1 AND e.Correcteur= 0 AND r.Login =e.Login\", num_defi)\r\n\tdefer row.Close()\r\n\tif err != nil {\r\n\t\tfmt.Printf(err.Error())\r\n\t} else {\r\n\t\tfor row.Next() {\r\n\t\t\trow.Scan(&res)\r\n\t\t\tt = append(t, res)\r\n\t\t}\r\n\t\taleatoire = rand.Intn(len(t))\r\n\t}\r\n\tlogfinal = t[aleatoire]\r\n\treturn logfinal\r\n}\r\n\r\n/**\r\nRécupère tous les résultats d'un étudiant à tous les défis auquel il a participé\r\n*/\r\nfunc GetAllResultat(login string) []ResBDD {\r\n\tvar res ResBDD\r\n\tresT := make([]ResBDD, 0)\r\n\trow, err := db.Query(\"SELECT * FROM Resultat WHERE login = ? ORDER BY defi ASC\", login)\r\n\tdefer row.Close()\r\n\tif err != nil {\r\n\t\tlogs.WriteLog(\"BDD.GetAllResultat\", err.Error())\r\n\t}\r\n\tfor row.Next() {\r\n\t\trow.Scan(&res.Login, &res.Defi, &res.Etat, &res.Tentative)\r\n\t\tresT = append(resT, res)\r\n\t}\r\n\r\n\treturn resT\r\n}\r\n\r\n/**\r\nRécupère tous les résultats de tous les étudiants pour un défi spécifique\r\n*/\r\nfunc GetParticipant(num_defi int) []ParticipantDefi {\r\n\tvar res ParticipantDefi\r\n\tresT := make([]ParticipantDefi, 0)\r\n\r\n\trow, err := db.Query(\"SELECT * FROM Etudiant e, Resultat r WHERE e.login = r.login AND r.defi = ? ORDER BY nom\", num_defi)\r\n\tdefer row.Close()\r\n\tif err != nil {\r\n\t\tlogs.WriteLog(\"BDD.GetParticipant\", err.Error())\r\n\t}\r\n\tfor row.Next() {\r\n\t\trow.Scan(&res.Etudiant.Login, &res.Etudiant.Password, &res.Etudiant.Prenom, &res.Etudiant.Nom, &res.Etudiant.Mail, &res.Etudiant.Correcteur, &res.Resultat.Login, &res.Resultat.Defi,\r\n\t\t\t&res.Resultat.Etat, &res.Resultat.Tentative)\r\n\t\tresT = append(resT, res)\r\n\t}\r\n\treturn resT\r\n}\r\n\r\nfunc GetEtudiantsMail() []EtudiantMail {\r\n\tvar res EtudiantMail\r\n\tresT := make([]EtudiantMail, 0)\r\n\r\n\trow, err := db.Query(\"SELECT  login, prenom, nom, mail FROM Etudiant;\")\r\n\tif err != nil {\r\n\t\tlogs.WriteLog(\"BDD.GetEtudiantsMail\", err.Error())\r\n\t} else if row != nil {\r\n\t\tfor row.Next() {\r\n\t\t\terr = row.Scan(&res.Login, &res.Prenom, &res.Nom, &res.Mail)\r\n\t\t\tif err != nil {\r\n\t\t\t\tpanic(err)\r\n\t\t\t}\r\n\t\t\tresT = append(resT, res)\r\n\t\t}\r\n\t}\r\n\r\n\tfor i, etu := range resT {\r\n\t\tetu.Defis = GetAllResultat(etu.Login)\r\n\t\tresT[i] = etu\r\n\t}\r\n\treturn resT\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/BDD/fonc_bdd.go b/BDD/fonc_bdd.go
--- a/BDD/fonc_bdd.go	(revision ee856f1f82121cb5fa800d63ba5b84157c2b8d75)
+++ b/BDD/fonc_bdd.go	(date 1614001250649)
@@ -8,6 +8,7 @@
 	"gitlab.univ-nantes.fr/E192543L/projet-s3/modele/logs"
 	"golang.org/x/crypto/bcrypt"
 	"math/rand"
+	"time"
 )
 
 // Structure a réutiliser un peu partout
@@ -429,7 +430,7 @@
 	var res string
 	var aleatoire int
 	var logfinal string
-	row, err := db.Query("Select Login FROM Resultat r, Etudiant e WHERE r.Defi = $1 AND r.Etat = 1 AND e.Correcteur= 0 AND r.Login =e.Login", num_defi)
+	row, err := db.Query("Select r.Login FROM Resultat r, Etudiant e WHERE r.Defi = $1 AND r.Etat = 1 AND e.Correcteur= 0 AND r.Login =e.Login", num_defi)
 	defer row.Close()
 	if err != nil {
 		fmt.Printf(err.Error())
@@ -439,11 +440,22 @@
 			t = append(t, res)
 		}
 		aleatoire = rand.Intn(len(t))
+		fmt.Println(t)
 	}
+	rand.Seed(time.Now().UnixNano())
+	min := 0
+	max := len(t) - 1
+	aleatoire = rand.Intn(max-min+1) + min
 	logfinal = t[aleatoire]
+	sqlStatement := "UPDATE Etudiant  SET correcteur = 1 WHERE login = $1 "
+	_, err = db.Exec(sqlStatement, logfinal)
+	if err != nil {
+		fmt.Printf(err.Error())
+	}
 	return logfinal
 }
 
+
 /**
 Récupère tous les résultats d'un étudiant à tous les défis auquel il a participé
 */
